using JuMP
using CPLEX

include("parser.jl")

start = time()

function P1(MyFileName::String)
  P, h, n, w1, w2, l, g, t = read_instance(MyFileName)
  w1 = 1
  w2 = 5

  # Create the model
  m = Model(CPLEX.Optimizer)

  ## Variables
  @variable(m, x[1:n+2,1:h+2], Bin)
  @variable(m, d[1:n+2,1:h+2] >= 0)

  ## Constraints
  @constraint(m, [i in 2:n+1, j in 2:h+1], d[i,j] <= x[i,j+1] + x[i+1,j] + x[i-1,j] + x[i,j-1] - 4 * (1 - x[i,j]))

  ## Objective
  @objective(m, Max, w1 * sum(t[i-1,j-1]*(1-x[i,j]) for i in 2:n+1, j in 2:h+1) + w2*g*l*sum(4*x[i,j] - d[i,j] for i in 2:n+1, j in 2:h+1))

  #resolution
  optimize!(m)

  # solution_summary(m, verbose=true)
  # z_vals = JuMP.getvalue.( m[:z] )
  # println(z_vals)

end

function P2(MyFileName::String)
  P, m, n, w1, w2, L, g, t = read_instance(MyFileName)

  # Create the model
  m = Model(CPLEX.Optimizer)

  ## Variables
  @variable(m, x[1:n,1:m], Bin)
  @variable(m, y[1:n,1:n], Bin)

  ## Constraints
  @constraint(m, [k in 1:P, i in 1:n, j in 1:n ; indice_danger[k] == 0], z[k,i,j] >= x[i,j]*log(1-Survie[k,i,j]))
  @constraint(m, [k in 1:P, i in 1:n, j in 1:n ; indice_danger[k] == 1], z[k,i,j] >= y[i,j]*log(1-Survie[k,i,j]))
  @constraint(m, [k in 1:P], sum(z[k,i,j] for i in 1:n, j in 1:n) <= log(1-alpha[k]))
  @constraint(m, [i in 1:n, j in 1:n ; i == 1 || j == 1 || i == n || j == n], y[i] <= 0)    # bordure => y = 0
  @constraint(m, [i in 2:n-1, j in 2:n-1], y[i,j] <= x[i,j])
  @constraint(m, [i in 2:n-1, j in 2:n-1], y[i,j] <= x[i-1,j])
  @constraint(m, [i in 2:n-1, j in 2:n-1], y[i,j] <= x[i+1,j])
  @constraint(m, [i in 2:n-1, j in 2:n-1], y[i,j] <= x[i,j-1])
  @constraint(m, [i in 2:n-1, j in 2:n-1], y[i,j] <= x[i,j+1])
  @constraint(m, [i in 2:n-1, j in 2:n-1], y[i,j] <= x[i-1,j-1])
  @constraint(m, [i in 2:n-1, j in 2:n-1], y[i,j] <= x[i-1,j+1])
  @constraint(m, [i in 2:n-1, j in 2:n-1], y[i,j] <= x[i+1,j-1])
  @constraint(m, [i in 2:n-1, j in 2:n-1], y[i,j] <= x[i+1,j+1])

  ## Objective
  @objective(m, Min, sum(x[i,j]*cout[i,j] for i in 1:n, j in 1:n))

  #resolution
  optimize!(m)

  # solution_summary(m, verbose=true)
  z_vals = JuMP.getvalue.( m[:z] )
  # println(z_vals)

  for k in 1:P
    println(-(exp(sum(z_vals[k,i,j] for i in 1:n, j in 1:n))-1))
  end

  # println(-(exp(sum(z[k,i,j] for i in 1:n, j in 1:n))-1))

end

P1("ExplForet_ampl.dat")
